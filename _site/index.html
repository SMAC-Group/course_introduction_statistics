<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction √† la Statistique</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-1d4f84655f446305ac42a8f1abcf7405.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="include/webex.css">
<link rel="stylesheet" href="include/chat.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Introduction √† la Statistique</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./demo_q_a.html"> 
<span class="menu-text">Demo</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./chatbot_slides.html"> 
<span class="menu-text">Chatbot Slides</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-exercices" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Exercices</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-exercices">    
        <li>
    <a class="dropdown-item" href="./exercices_semaine_1.html">
 <span class="dropdown-text">Exercices Semaine 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_2.html">
 <span class="dropdown-text">Exercices Semaine 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_3.html">
 <span class="dropdown-text">Exercices Semaine 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_4.html">
 <span class="dropdown-text">Exercices Semaine 4</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_5.html">
 <span class="dropdown-text">Exercices Semaine 5</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_6.html">
 <span class="dropdown-text">Exercices Semaine 6</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_8.html">
 <span class="dropdown-text">Exercices Semaine 8</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_9.html">
 <span class="dropdown-text">Exercices Semaine 9</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_11.html">
 <span class="dropdown-text">Exercices Semaine 11</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./exercices_semaine_12.html">
 <span class="dropdown-text">Exercices Semaine 12</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SMAC-Group/course_introduction_statistics"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<div class="hero-section">
<div class="hero-content">
<div class="hero-title">
Plateforme d‚Äôexercices
</div>
<p class="hero-subtitle">
Introduction √† la Statistique
</p>
<p class="hero-description">
Ce site te permet de t‚Äôentra√Æner chaque semaine avec des exercices interactifs.<br>Les supports de cours sont disponibles sur la plateforme officielle de l‚Äôuniversit√©.
</p>
<div class="hero-buttons">
<p><a href="#exercices" class="hero-button primary">Acc√©der aux exercices</a> <a href="#" class="hero-button secondary" title="Lien Moodle √† ajouter">Supports de cours</a></p>
</div>
</div>
</div>
<div id="exercices" class="content-section">
<section id="exercices-par-semaine" class="level2">
<h2 class="anchored" data-anchor-id="exercices-par-semaine">Exercices par semaine</h2>
<div class="week-grid">
<a href="exercices_semaine_1.html" class="week-card available">
<div class="week-number">
Semaine 1
</div>
<div class="week-topic">
Probabilit√©s de base
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_1.html" class="week-card available"></a></p>
<a href="exercices_semaine_2.html" class="week-card available">
<div class="week-number">
Semaine 2
</div>
<div class="week-topic">
Probabilit√©s conditionnelles
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_2.html" class="week-card available"></a></p>
<a href="exercices_semaine_3.html" class="week-card available">
<div class="week-number">
Semaine 3
</div>
<div class="week-topic">
Variables al√©atoires
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_3.html" class="week-card available"></a></p>
<a href="exercices_semaine_4.html" class="week-card available">
<div class="week-number">
Semaine 4
</div>
<div class="week-topic">
Loi binomiale
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_4.html" class="week-card available"></a></p>
<a href="exercices_semaine_5.html" class="week-card available">
<div class="week-number">
Semaine 5
</div>
<div class="week-topic">
Loi normale
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_5.html" class="week-card available"></a></p>
<a href="exercices_semaine_6.html" class="week-card available">
<div class="week-number">
Semaine 6
</div>
<div class="week-topic">
Statistiques descriptives
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_6.html" class="week-card available"></a></p>
<div class="week-card holiday">
<div class="week-number">
Semaine 7
</div>
<div class="week-topic">
Pas de cours
</div>
<div class="week-status holiday">
Vacances
</div>
</div>
<a href="exercices_semaine_8.html" class="week-card available">
<div class="week-number">
Semaine 8
</div>
<div class="week-topic">
√âchantillonnage
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_8.html" class="week-card available"></a></p>
<a href="exercices_semaine_9.html" class="week-card available">
<div class="week-number">
Semaine 9
</div>
<div class="week-topic">
Intervalles de confiance
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_9.html" class="week-card available"></a></p>
<div class="week-card exam">
<div class="week-number">
Semaine 10
</div>
<div class="week-topic">
Examen interm√©diaire
</div>
<div class="week-status exam">
Examen
</div>
</div>
<a href="exercices_semaine_11.html" class="week-card available">
<div class="week-number">
Semaine 11
</div>
<div class="week-topic">
Intervalles de confiance (suite)
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_11.html" class="week-card available"></a></p>
<a href="exercices_semaine_12.html" class="week-card available">
<div class="week-number">
Semaine 12
</div>
<div class="week-topic">
Tests d‚Äôhypoth√®ses
</div>
<div class="week-status available">
Disponible
</div>
</a><p><a href="exercices_semaine_12.html" class="week-card available"></a></p>
<div class="week-card exam">
<div class="week-number">
Semaine 13
</div>
<div class="week-topic">
Examen final
</div>
<div class="week-status exam">
Examen
</div>
</div>
</div>
</section>
</div>
<section id="sentra√Æner-pour-les-examens" class="level2 content-section exam-section">
<h2 class="anchored" data-anchor-id="sentra√Æner-pour-les-examens">S‚Äôentra√Æner pour les examens</h2>
<div class="exam-grid">
<a href="#" class="exam-card disabled" title="Contenu √† venir">
<div class="exam-icon">
üìù
</div>
<div class="exam-title">
Examen interm√©diaire
</div>
<div class="exam-subtitle">
Entra√Ænement
</div>
<div class="exam-status">
√Ä venir
</div>
</a><p><a href="#" class="exam-card disabled" title="Contenu √† venir"></a></p>
<a href="#" class="exam-card disabled" title="Contenu √† venir">
<div class="exam-icon">
üìù
</div>
<div class="exam-title">
Examen final
</div>
<div class="exam-subtitle">
Entra√Ænement
</div>
<div class="exam-status">
√Ä venir
</div>
</a><p><a href="#" class="exam-card disabled" title="Contenu √† venir"></a></p>
</div>
</section>
<div class="footer-section">
<div class="footer-content">
<p class="footer-about">
Ce site est un support d‚Äôexercices pour le cours Introduction √† la Statistique.<br>Il est con√ßu pour t‚Äôaider √† pratiquer et √† te pr√©parer aux examens.
</p>
<p class="footer-team">
D√©velopp√© par St√©phane Guerrier, Mucyo Karemera, Samuel Orso et Lionel Voirol
</p>
<p><img src="img/licence.png" width="60px" alt="Copyright License"></p>
</div>
</div>



</main> <!-- /main -->
<script>



/* update total correct if #webex-total_correct exists */

update_total_correct = function() {

  console.log("webex: update total_correct");



  var t = document.getElementsByClassName("webex-total_correct");

  for (var i = 0; i < t.length; i++) {

    p = t[i].parentElement;

    var correct = p.getElementsByClassName("webex-correct").length;

    var solvemes = p.getElementsByClassName("webex-solveme").length;

    var radiogroups = p.getElementsByClassName("webex-radiogroup").length;

    var selects = p.getElementsByClassName("webex-select").length;



    t[i].innerHTML = correct + " of " + (solvemes + radiogroups + selects) + " correct";

  }

}



/* webex-solution button toggling function */

b_func = function() {

  console.log("webex: toggle hide");



  var cl = this.parentElement.classList;

  if (cl.contains('open')) {

    cl.remove("open");

  } else {

    cl.add("open");

  }

}



/* check answers */

check_func = function() {

  console.log("webex: check answers");



  var cl = this.parentElement.classList;

  if (cl.contains('unchecked')) {

    cl.remove("unchecked");

    this.innerHTML = "Hide Answers";

  } else {

    cl.add("unchecked");

    this.innerHTML = "Solution";

  }

}



/* function for checking solveme answers */

solveme_func = function(e) {

  console.log("webex: check solveme");



  var real_answers = JSON.parse(this.dataset.answer);

  var my_answer = this.value;

  var cl = this.classList;

  if (cl.contains("ignorecase")) {

    my_answer = my_answer.toLowerCase();

  }

  if (cl.contains("nospaces")) {

    my_answer = my_answer.replace(/ /g, "")

  }



  if (my_answer == "") {

    cl.remove("webex-correct");

    cl.remove("webex-incorrect");

  } else if (real_answers.includes(my_answer)) {

    cl.add("webex-correct");

    cl.remove("webex-incorrect");

  } else {

    cl.add("webex-incorrect");

    cl.remove("webex-correct");

  }



  // match numeric answers within a specified tolerance

  if(this.dataset.tol > 0){

    var tol = JSON.parse(this.dataset.tol);

    var matches = real_answers.map(x => Math.abs(x - my_answer) < tol)

    if (matches.reduce((a, b) => a + b, 0) > 0) {

      cl.add("webex-correct");

    } else {

      cl.remove("webex-correct");

    }

  }



  // added regex bit

  if (cl.contains("regex")){

    answer_regex = RegExp(real_answers.join("|"))

    if (answer_regex.test(my_answer)) {

      cl.add("webex-correct");

    }

  }



  update_total_correct();

}



/* function for checking select answers */

select_func = function(e) {

  console.log("webex: check select");



  var cl = this.classList



  /* add style */

  cl.remove("webex-incorrect");

  cl.remove("webex-correct");

  if (this.value == "answer") {

    cl.add("webex-correct");

  } else if (this.value != "blank") {

    cl.add("webex-incorrect");

  }



  update_total_correct();

}



/* function for checking radiogroups answers */

radiogroups_func = function(e) {

  console.log("webex: check radiogroups");



  var checked_button = document.querySelector('input[name=' + this.id + ']:checked');

  var cl = checked_button.parentElement.classList;

  var labels = checked_button.parentElement.parentElement.children;



  /* get rid of styles */

  for (i = 0; i < labels.length; i++) {

    labels[i].classList.remove("webex-incorrect");

    labels[i].classList.remove("webex-correct");

  }



  /* add style */

  if (checked_button.value == "answer") {

    cl.add("webex-correct");

  } else {

    cl.add("webex-incorrect");

  }



  update_total_correct();

}



window.onload = function() {

  console.log("webex onload");

  /* set up solution buttons */

  var buttons = document.getElementsByTagName("button");



  for (var i = 0; i < buttons.length; i++) {

    if (buttons[i].parentElement.classList.contains('webex-solution')) {

      buttons[i].onclick = b_func;

    }

  }



  var check_sections = document.getElementsByClassName("webex-check");

  console.log("check:", check_sections.length);

  for (var i = 0; i < check_sections.length; i++) {

    check_sections[i].classList.add("unchecked");



    let btn = document.createElement("button");

    btn.innerHTML = "Solution";

    btn.classList.add("webex-check-button");

    btn.onclick = check_func;

    check_sections[i].appendChild(btn);



    let spn = document.createElement("span");

    spn.classList.add("webex-total_correct");

    check_sections[i].appendChild(spn);

  }



  /* set up webex-solveme inputs */

  var solveme = document.getElementsByClassName("webex-solveme");



  for (var i = 0; i < solveme.length; i++) {

    /* make sure input boxes don't auto-anything */

    solveme[i].setAttribute("autocomplete","off");

    solveme[i].setAttribute("autocorrect", "off");

    solveme[i].setAttribute("autocapitalize", "off");

    solveme[i].setAttribute("spellcheck", "false");

    solveme[i].value = "";



    /* adjust answer for ignorecase or nospaces */

    var cl = solveme[i].classList;

    var real_answer = solveme[i].dataset.answer;

    if (cl.contains("ignorecase")) {

      real_answer = real_answer.toLowerCase();

    }

    if (cl.contains("nospaces")) {

      real_answer = real_answer.replace(/ /g, "");

    }

    solveme[i].dataset.answer = real_answer;



    /* attach checking function */

    solveme[i].onkeyup = solveme_func;

    solveme[i].onchange = solveme_func;



    solveme[i].insertAdjacentHTML("afterend", " <span class='webex-icon'></span>")

  }



  /* set up radiogroups */

  var radiogroups = document.getElementsByClassName("webex-radiogroup");

  for (var i = 0; i < radiogroups.length; i++) {

    radiogroups[i].onchange = radiogroups_func;

  }



  /* set up selects */

  var selects = document.getElementsByClassName("webex-select");

  for (var i = 0; i < selects.length; i++) {

    selects[i].onchange = select_func;

    selects[i].insertAdjacentHTML("afterend", " <span class='webex-icon'></span>")

  }



  update_total_correct();

}



</script>

<script>

/* AI Help Chat - Scaffolded Tutor Side Panel */

(function() {

  let conversationHistory = [];

  let currentContext = null;

  let chatPanel = null;

  let aiTurnCount = 0;

  let styleMode = 'classique'; // 'classique', 'fun', or 'sceptique'

  let currentQuestionId = null; // Track which question the assistant is scoped to

  let tokenInfo = { used: 0, remaining: 50000, max: 50000 }; // Token quota tracking



  // Detect current page source (semaine) from URL

  function detectSource() {

    const path = window.location.pathname;

    const match = path.match(/semaine[_-]?(\d+)/i);

    if (match) {

      return 'semaine_' + match[1];

    }

    return null;

  }



  // Panel width settings

  const MIN_WIDTH = 320;

  const MAX_WIDTH = 800;

  const DEFAULT_WIDTH = 500;

  let panelWidth = parseInt(localStorage.getItem('aiChatPanelWidth')) || DEFAULT_WIDTH;



  // Generate a unique ID for a question based on its text

  function generateQuestionId(questionText) {

    // Simple hash based on question text

    let hash = 0;

    for (let i = 0; i < questionText.length; i++) {

      const char = questionText.charCodeAt(i);

      hash = ((hash << 5) - hash) + char;

      hash = hash & hash; // Convert to 32bit integer

    }

    return 'q_' + Math.abs(hash);

  }



  // Get current selected answer from the radio group near the button

  function getCurrentStudentAnswer() {

    if (!currentContext || !currentContext.buttonElement) return null;



    const questionButtons = currentContext.buttonElement.closest('.question-buttons');

    if (!questionButtons) return null;



    let sibling = questionButtons.previousElementSibling;

    while (sibling) {

      if (sibling.classList && sibling.classList.contains('webex-radiogroup')) {

        const selectedRadio = sibling.querySelector('input[type="radio"]:checked');

        if (selectedRadio) {

          const label = selectedRadio.closest('label');

          if (label) {

            const span = label.querySelector('span');

            if (span) {

              // Try to get original LaTeX from MathJax annotation

              const annotation = span.querySelector('annotation[encoding="application/x-tex"]');

              if (annotation) {

                return annotation.textContent;

              }

              // Fallback: try to get from mjx-assistive-mml

              const assistive = span.querySelector('mjx-assistive-mml math');

              if (assistive) {

                // Extract fraction if present

                const mfrac = assistive.querySelector('mfrac');

                if (mfrac) {

                  const nums = mfrac.querySelectorAll('mn');

                  if (nums.length === 2) {

                    return nums[0].textContent + '/' + nums[1].textContent;

                  }

                }

                return assistive.textContent;

              }

              // Last fallback: innerHTML cleaned up

              let text = span.innerHTML;

              // Remove MathJax containers and get plain text

              text = text.replace(/<mjx-container[^>]*>.*?<\/mjx-container>/gs, '');

              text = text.replace(/<[^>]+>/g, '').trim();

              if (text) return text;

              // Very last fallback

              return span.textContent;

            }

          }

        }

        break;

      }

      sibling = sibling.previousElementSibling;

    }

    return null;

  }



  // Markdown parser for AI responses

  function parseMarkdown(text) {

    // Bold: **text** -> <strong>text</strong>

    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

    // Italic: *text* -> <em>text</em> (but not inside URLs or already processed)

    text = text.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');



    // Process line by line for better list and paragraph handling

    const lines = text.split('\n');

    let result = [];

    let inList = false;

    let listType = null;

    let paragraphLines = [];



    function flushParagraph() {

      if (paragraphLines.length > 0) {

        result.push('<p>' + paragraphLines.join(' ') + '</p>');

        paragraphLines = [];

      }

    }



    for (let line of lines) {

      const trimmedLine = line.trim();



      // Check for headers (####, ###, ##)

      const h4Match = trimmedLine.match(/^####\s+(.+)$/);

      const h3Match = trimmedLine.match(/^###\s+(.+)$/);

      const h2Match = trimmedLine.match(/^##\s+(.+)$/);

      // Check for bullet points (- or ‚Ä¢)

      const bulletMatch = trimmedLine.match(/^[\-‚Ä¢]\s+(.+)$/);

      // Check for numbered lists (1. 2. etc)

      const numberedMatch = trimmedLine.match(/^\d+\.\s+(.+)$/);



      if (h4Match) {

        flushParagraph();

        if (inList) {

          result.push(listType === 'ol' ? '</ol>' : '</ul>');

          inList = false;

          listType = null;

        }

        result.push(`<h5>${h4Match[1]}</h5>`);

      } else if (h3Match) {

        flushParagraph();

        if (inList) {

          result.push(listType === 'ol' ? '</ol>' : '</ul>');

          inList = false;

          listType = null;

        }

        result.push(`<h4>${h3Match[1]}</h4>`);

      } else if (h2Match) {

        flushParagraph();

        if (inList) {

          result.push(listType === 'ol' ? '</ol>' : '</ul>');

          inList = false;

          listType = null;

        }

        result.push(`<h4>${h2Match[1]}</h4>`);

      } else if (bulletMatch) {

        flushParagraph();

        if (listType !== 'ul') {

          if (inList) result.push(listType === 'ol' ? '</ol>' : '</ul>');

          result.push('<ul>');

          inList = true;

          listType = 'ul';

        }

        result.push(`<li>${bulletMatch[1]}</li>`);

      } else if (numberedMatch) {

        flushParagraph();

        if (listType !== 'ol') {

          if (inList) result.push(listType === 'ul' ? '</ul>' : '</ol>');

          result.push('<ol>');

          inList = true;

          listType = 'ol';

        }

        result.push(`<li>${numberedMatch[1]}</li>`);

      } else {

        if (inList) {

          result.push(listType === 'ol' ? '</ol>' : '</ul>');

          inList = false;

          listType = null;

        }

        if (trimmedLine) {

          paragraphLines.push(trimmedLine);

        } else {

          flushParagraph();

        }

      }

    }



    // Close any open list

    if (inList) {

      result.push(listType === 'ol' ? '</ol>' : '</ul>');

    }

    flushParagraph();



    return result.join('');

  }



  // Create side panel HTML - chips at TOP

  function createChatPanel() {

    const panel = document.createElement('div');

    panel.id = 'ai-chat-panel';

    panel.className = 'ai-chat-panel';

    panel.style.width = panelWidth + 'px';

    panel.style.right = '-' + (panelWidth + 20) + 'px';

    panel.innerHTML = `

      <div class="ai-chat-resize-handle" id="ai-chat-resize-handle" title="Glisser pour redimensionner"></div>

      <div class="ai-chat-header">

        <h3>Aide IA</h3>

        <div class="style-selector" title="Choisis le style d'aide">

          <button class="style-btn active" data-style="classique" onclick="window.AIChat.setStyle('classique')">

            <span class="style-emoji">üß≠</span>

            <span class="style-label">Classique</span>

          </button>

          <button class="style-btn" data-style="fun" onclick="window.AIChat.setStyle('fun')">

            <span class="style-emoji">ü§©</span>

            <span class="style-label">Fun</span>

          </button>

          <button class="style-btn" data-style="sceptique" onclick="window.AIChat.setStyle('sceptique')">

            <span class="style-emoji">ü§®</span>

            <span class="style-label">Sceptique</span>

          </button>

        </div>

        <div class="header-spacer"></div>

        <button class="ai-chat-close" onclick="window.AIChat.close()" title="Fermer">

          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">

            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>

          </svg>

        </button>

      </div>

      <div class="ai-chat-context" id="ai-chat-context"></div>

      <div class="ai-chat-chips" id="ai-chat-chips">

        <button class="ai-chip" data-intent="HINT" onclick="window.AIChat.sendIntent('HINT')">

          ‚ùì Indice

        </button>

        <button class="ai-chip" data-intent="EXPLANATION" onclick="window.AIChat.sendIntent('EXPLANATION')">

          üí° Explication

        </button>

        <button class="ai-chip" data-intent="WHY_WRONG" onclick="window.AIChat.sendIntent('WHY_WRONG')">

          ‚ùå Pourquoi c'est faux?

        </button>

        <button class="ai-chip" data-intent="CHECK_REASONING" onclick="window.AIChat.sendIntent('CHECK_REASONING')">

          ‚úÖ V√©rifie mon raisonnement

        </button>

        <button class="ai-chip" data-intent="SIMILAR_QUESTION" onclick="window.AIChat.sendIntent('SIMILAR_QUESTION')">

          üéØ Question similaire

        </button>

      </div>

      <div class="ai-chat-messages" id="ai-chat-messages">

        <div class="ai-chat-welcome">

          <p>Je suis ton assistant pour cet exercice.<br>Utilise les boutons ci-dessus pour obtenir des pistes, puis pose ta question ci-dessous pour approfondir ou clarifier un point.</p>

        </div>

      </div>

      <div class="ai-chat-input-area">

        <input type="text" id="ai-chat-input" placeholder="Pose ta question..." autocomplete="off">

        <button class="ai-chat-send" id="ai-chat-send" title="Envoyer">

          <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">

            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>

          </svg>

        </button>

      </div>

      <div class="ai-chat-token-info" id="ai-chat-token-info">

        <div class="token-bar-container">

          <div class="token-bar" id="token-bar"></div>

        </div>

        <span class="token-text" id="token-text">Tokens: -- / --</span>

      </div>

    `;

    document.body.appendChild(panel);

    chatPanel = panel;



    document.getElementById('ai-chat-send').addEventListener('click', () => sendMessage('FREE_TEXT'));

    document.getElementById('ai-chat-input').addEventListener('keypress', (e) => {

      if (e.key === 'Enter') sendMessage('FREE_TEXT');

    });



    // Setup resize functionality

    setupResizeHandle();



    // Initialize token display

    updateTokenDisplay();

  }



  // Resize handle functionality

  function setupResizeHandle() {

    const handle = document.getElementById('ai-chat-resize-handle');

    if (!handle) return;



    let isResizing = false;

    let startX, startWidth;



    handle.addEventListener('mousedown', (e) => {

      isResizing = true;

      startX = e.clientX;

      startWidth = chatPanel.offsetWidth;

      document.body.style.cursor = 'ew-resize';

      document.body.style.userSelect = 'none';

      e.preventDefault();

    });



    document.addEventListener('mousemove', (e) => {

      if (!isResizing) return;



      // Calculate new width (dragging left = increase width, right = decrease)

      const diff = startX - e.clientX;

      let newWidth = startWidth + diff;



      // Clamp to min/max

      newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, newWidth));



      // Apply width

      chatPanel.style.width = newWidth + 'px';

      panelWidth = newWidth;



      // Update body margin if panel is open

      if (chatPanel.classList.contains('open')) {

        document.body.style.marginRight = (newWidth + 10) + 'px';

      }

    });



    document.addEventListener('mouseup', () => {

      if (isResizing) {

        isResizing = false;

        document.body.style.cursor = '';

        document.body.style.userSelect = '';

        // Save width preference

        localStorage.setItem('aiChatPanelWidth', panelWidth);

      }

    });



    // Touch support for mobile

    handle.addEventListener('touchstart', (e) => {

      isResizing = true;

      startX = e.touches[0].clientX;

      startWidth = chatPanel.offsetWidth;

      e.preventDefault();

    });



    document.addEventListener('touchmove', (e) => {

      if (!isResizing) return;

      const diff = startX - e.touches[0].clientX;

      let newWidth = startWidth + diff;

      newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, newWidth));

      chatPanel.style.width = newWidth + 'px';

      panelWidth = newWidth;

      if (chatPanel.classList.contains('open')) {

        document.body.style.marginRight = (newWidth + 10) + 'px';

      }

    });



    document.addEventListener('touchend', () => {

      if (isResizing) {

        isResizing = false;

        localStorage.setItem('aiChatPanelWidth', panelWidth);

      }

    });

  }



  // Check if the student's answer is correct

  function isAnswerCorrect(studentAnswer) {

    if (!studentAnswer || !currentContext || !currentContext.correctAnswer) return null;



    // Normalize both answers for comparison (remove spaces, lowercase)

    const normalize = (s) => s.replace(/\s+/g, '').toLowerCase();

    return normalize(studentAnswer) === normalize(currentContext.correctAnswer);

  }



  // Short congratulatory messages

  const shortCongrats = [

    'Bravo üòä',

    'Bravo üéâ',

    'Bravo üëè',

    'Super üåü',

    'Parfait ‚ú®',

    'Excellent üí™'

  ];



  function getRandomCongrats() {

    return shortCongrats[Math.floor(Math.random() * shortCongrats.length)];

  }



  // Update the context display with current student answer

  function updateContextDisplay() {

    const contextDiv = document.getElementById('ai-chat-context');

    if (!contextDiv || !currentContext) return;



    const studentAnswer = getCurrentStudentAnswer();

    const correct = isAnswerCorrect(studentAnswer);



    let contextHtml = `<strong>Question:</strong> ${currentContext.question}`;

    if (studentAnswer) {

      let statusBadge = '';

      if (correct === true) {

        statusBadge = ' <span style="color: #28a745; font-weight: bold;">(correct)</span> ‚Äî ' + getRandomCongrats();

      } else if (correct === false) {

        statusBadge = ' <span style="color: #dc3545; font-weight: bold;">(incorrect)</span>';

      }

      contextHtml += `<br><strong>Votre r√©ponse:</strong> ${studentAnswer}${statusBadge}`;

    } else {

      contextHtml += `<br><strong>Votre r√©ponse:</strong> <em style="color: #888;">Pas s√©lectionn√©e</em>`;

    }

    contextDiv.innerHTML = contextHtml;



    // Update chips visibility based on answer state

    updateChipsVisibility(correct);



    if (window.MathJax) {

      MathJax.typesetPromise([contextDiv]);

    }

  }



  // Show/hide chips based on whether answer is correct

  function updateChipsVisibility(correct) {

    const hintChip = document.querySelector('.ai-chip[data-intent="HINT"]');

    const explanationChip = document.querySelector('.ai-chip[data-intent="EXPLANATION"]');

    const whyWrongChip = document.querySelector('.ai-chip[data-intent="WHY_WRONG"]');

    const checkReasoningChip = document.querySelector('.ai-chip[data-intent="CHECK_REASONING"]');

    const similarQuestionChip = document.querySelector('.ai-chip[data-intent="SIMILAR_QUESTION"]');



    if (correct === true) {

      // Correct answer: show "V√©rifie mon raisonnement" and "Question similaire"

      if (hintChip) hintChip.style.display = 'none';

      if (explanationChip) explanationChip.style.display = 'none';

      if (whyWrongChip) whyWrongChip.style.display = 'none';

      if (checkReasoningChip) checkReasoningChip.style.display = 'inline-block';

      if (similarQuestionChip) similarQuestionChip.style.display = 'inline-block';

    } else if (correct === false) {

      // Wrong answer: show hint, explanation, and why wrong

      if (hintChip) hintChip.style.display = 'inline-block';

      if (explanationChip) explanationChip.style.display = 'inline-block';

      if (whyWrongChip) whyWrongChip.style.display = 'inline-block';

      if (checkReasoningChip) checkReasoningChip.style.display = 'none';

      if (similarQuestionChip) similarQuestionChip.style.display = 'none';

    } else {

      // No answer selected: show hint and explanation

      if (hintChip) hintChip.style.display = 'inline-block';

      if (explanationChip) explanationChip.style.display = 'inline-block';

      if (whyWrongChip) whyWrongChip.style.display = 'none';

      if (checkReasoningChip) checkReasoningChip.style.display = 'none';

      if (similarQuestionChip) similarQuestionChip.style.display = 'none';

    }

  }



  // Open panel with question context

  function openChat(question, hint, explanation, correctAnswer, buttonElement) {

    if (!chatPanel) createChatPanel();



    const newQuestionId = generateQuestionId(question);

    const isQuestionChange = currentQuestionId !== null && currentQuestionId !== newQuestionId;

    const wasPanelOpen = chatPanel && chatPanel.classList.contains('open');



    // Check if we're switching to a different question

    if (isQuestionChange || currentQuestionId === null) {

      // RESET for new question (per specification)

      conversationHistory = [];

      aiTurnCount = 0;



      // Reset style mode to 'classique' on question change

      styleMode = 'classique';

      document.querySelectorAll('.style-btn').forEach(btn => {

        btn.classList.toggle('active', btn.dataset.style === 'classique');

      });

    }



    currentQuestionId = newQuestionId;



    // Store context with button reference for dynamic answer lookup

    currentContext = {

      question,

      hint,

      explanation,

      correctAnswer,

      buttonElement,

      attemptCount: 0

    };



    // Update context display

    updateContextDisplay();



    // Add listeners to radio buttons to update context when answer changes

    if (buttonElement) {

      const questionButtons = buttonElement.closest('.question-buttons');

      if (questionButtons) {

        let sibling = questionButtons.previousElementSibling;

        while (sibling) {

          if (sibling.classList && sibling.classList.contains('webex-radiogroup')) {

            const radios = sibling.querySelectorAll('input[type="radio"]');

            radios.forEach(radio => {

              // Remove old listener to avoid duplicates, then add new one

              radio.removeEventListener('change', updateContextDisplay);

              radio.addEventListener('change', updateContextDisplay);

            });

            break;

          }

          sibling = sibling.previousElementSibling;

        }

      }

    }



    const messagesDiv = document.getElementById('ai-chat-messages');



    // Show welcome message (fresh for new question)

    messagesDiv.innerHTML = `

      <div class="ai-chat-welcome">

        <p>Je suis ton assistant pour cette question.<br>Utilise les boutons ci-dessus pour obtenir des pistes, puis pose ta question ci-dessous pour approfondir ou clarifier un point.</p>

      </div>

    `;



    // If panel was already open and we switched questions, show a subtle notification

    if (wasPanelOpen && isQuestionChange) {

      showContextSwitchNotification();

    }



    chatPanel.classList.add('open');

    chatPanel.style.right = '0';

    document.body.style.marginRight = (panelWidth + 10) + 'px';



    const contextDiv = document.getElementById('ai-chat-context');

    if (window.MathJax && contextDiv) {

      MathJax.typesetPromise([contextDiv]);

    }

  }



  // Show a subtle notification when context switches

  function showContextSwitchNotification() {

    const messagesDiv = document.getElementById('ai-chat-messages');

    const notification = document.createElement('div');

    notification.className = 'ai-context-switch-notice';

    notification.innerHTML = 'üîÑ Assistant mis √† jour pour la nouvelle question';

    messagesDiv.insertBefore(notification, messagesDiv.firstChild);



    // Fade out after 3 seconds

    setTimeout(() => {

      notification.style.opacity = '0';

      setTimeout(() => notification.remove(), 500);

    }, 3000);

  }



  // Close panel

  function closeChat() {

    if (chatPanel) {

      chatPanel.classList.remove('open');

      chatPanel.style.right = '-' + (panelWidth + 20) + 'px';

      document.body.style.marginRight = '';

    }

  }



  // Send message with intent

  async function sendIntent(intent) {

    const intentMessages = {

      'HINT': 'Peux-tu me donner un indice?',

      'EXPLANATION': 'Peux-tu m\'expliquer ce probl√®me et le concept test√©?',

      'WHY_WRONG': 'Pourquoi ma r√©ponse est-elle fausse?',

      'CHECK_REASONING': 'Peux-tu v√©rifier mon raisonnement?',

      'SIMILAR_QUESTION': 'Peux-tu me proposer une question similaire pour m\'entra√Æner?'

    };



    const message = intentMessages[intent] || '';

    await sendMessage(intent, message);

  }



  // Send message

  async function sendMessage(intent, presetMessage = null) {

    const input = document.getElementById('ai-chat-input');

    const message = presetMessage || input.value.trim();



    if (!message && intent === 'FREE_TEXT') return;



    input.value = '';



    const welcome = document.querySelector('.ai-chat-welcome');

    if (welcome) welcome.remove();



    // Show user message

    if (message) {

      addMessage(message, 'user');

    }



    const typing = addTypingIndicator();

    aiTurnCount++;



    // Get current student answer dynamically (in case they changed it)

    const studentAnswer = getCurrentStudentAnswer();

    updateContextDisplay();



    // Determine if answer is correct (for context flag, but don't send the actual answer)

    const answerCorrect = isAnswerCorrect(studentAnswer);



    try {

      const response = await fetch('/.netlify/functions/chat', {

        method: 'POST',

        headers: { 'Content-Type': 'application/json' },

        body: JSON.stringify({

          message: message,

          conversationHistory: conversationHistory,

          context: {

            question: currentContext.question,

            hint: currentContext.hint,

            studentAnswer: studentAnswer,

            isCorrect: answerCorrect,

            attemptCount: studentAnswer ? 1 : 0,

            aiTurnCount: aiTurnCount,

            intent: intent,

            styleMode: styleMode,

            source: detectSource()

          }

        })

      });



      const data = await response.json();

      typing.remove();



      // Update token display

      if (data.tokens) {

        updateTokenDisplay(data.tokens);

      }



      if (data.error) {

        addMessage(data.error, 'error');

        // Also update token display from error response (quota exceeded)

        if (data.tokensUsed !== undefined) {

          updateTokenDisplay({

            used: data.tokensUsed,

            remaining: data.tokensRemaining,

            max: data.tokensMax

          });

        }

      } else {

        conversationHistory.push({ role: 'user', content: message });

        conversationHistory.push({ role: 'assistant', content: data.response });



        if (conversationHistory.length > 20) {

          conversationHistory = conversationHistory.slice(-20);

        }



        // Parse markdown before displaying

        const formattedResponse = parseMarkdown(data.response);

        addMessage(formattedResponse, 'assistant');

      }

    } catch (error) {

      typing.remove();

      addMessage('Erreur de connexion. Veuillez r√©essayer.', 'error');

    }

  }



  function addMessage(content, type) {

    const messages = document.getElementById('ai-chat-messages');

    const msgDiv = document.createElement('div');

    msgDiv.className = `ai-chat-message ${type}`;

    msgDiv.innerHTML = content;

    messages.appendChild(msgDiv);

    messages.scrollTop = messages.scrollHeight;



    if (window.MathJax && type === 'assistant') {

      MathJax.typesetPromise([msgDiv]);

    }



    return msgDiv;

  }



  function addTypingIndicator() {

    const messages = document.getElementById('ai-chat-messages');

    const typing = document.createElement('div');

    typing.className = 'ai-typing-indicator';

    typing.innerHTML = '<span></span><span></span><span></span>';

    messages.appendChild(typing);

    messages.scrollTop = messages.scrollHeight;

    return typing;

  }



  function setStyleMode(mode) {

    styleMode = mode;

    // Update button states

    document.querySelectorAll('.style-btn').forEach(btn => {

      btn.classList.toggle('active', btn.dataset.style === mode);

    });

  }



  // Update token display

  function updateTokenDisplay(tokens) {

    if (tokens) {

      tokenInfo = {

        used: tokens.used || tokenInfo.used,

        remaining: tokens.remaining !== undefined ? tokens.remaining : tokenInfo.remaining,

        max: tokens.max || tokenInfo.max,

        lastRequest: tokens.total || 0

      };

    }



    const tokenBar = document.getElementById('token-bar');

    const tokenText = document.getElementById('token-text');



    if (tokenBar && tokenText) {

      const percentage = Math.max(0, Math.min(100, (tokenInfo.remaining / tokenInfo.max) * 100));

      tokenBar.style.width = percentage + '%';



      // Color based on remaining tokens

      if (percentage > 50) {

        tokenBar.style.backgroundColor = '#28a745'; // Green

      } else if (percentage > 20) {

        tokenBar.style.backgroundColor = '#ffc107'; // Yellow

      } else {

        tokenBar.style.backgroundColor = '#dc3545'; // Red

      }



      // Format numbers with thousands separator

      const formatNum = (n) => n.toLocaleString('fr-FR');

      tokenText.textContent = `Tokens: ${formatNum(tokenInfo.remaining)} / ${formatNum(tokenInfo.max)}`;



      if (tokenInfo.lastRequest > 0) {

        tokenText.title = `Derni√®re requ√™te: ${tokenInfo.lastRequest} tokens`;

      }

    }

  }



  window.openAIHelp = function(question, hint, explanation, correctAnswer, buttonElement) {

    openChat(question, hint, explanation, correctAnswer, buttonElement);

  };



  window.AIChat = {

    open: openChat,

    close: closeChat,

    sendIntent: sendIntent,

    setStyle: setStyleMode

  };

})();

</script>

<script>

/* Site Features: Dark Mode, Progress Tracking, Question Badges, Breadcrumbs */

(function() {

  'use strict';



  // =============================================

  // DARK MODE

  // =============================================

  function initDarkMode() {

    // Check for saved preference only - default to light mode

    const savedTheme = localStorage.getItem('theme');



    // Only use dark mode if explicitly saved by user

    if (savedTheme === 'dark') {

      document.documentElement.setAttribute('data-theme', 'dark');

    } else {

      document.documentElement.setAttribute('data-theme', 'light');

    }



    // Add toggle button to navbar

    const navbar = document.querySelector('.navbar-nav');

    if (navbar) {

      const toggleBtn = document.createElement('button');

      toggleBtn.className = 'theme-toggle';

      toggleBtn.setAttribute('aria-label', 'Changer le th√®me');

      toggleBtn.innerHTML = `

        <svg class="moon-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">

          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>

        </svg>

        <svg class="sun-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">

          <circle cx="12" cy="12" r="5"/>

          <line x1="12" y1="1" x2="12" y2="3" stroke="currentColor" stroke-width="2"/>

          <line x1="12" y1="21" x2="12" y2="23" stroke="currentColor" stroke-width="2"/>

          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke="currentColor" stroke-width="2"/>

          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke="currentColor" stroke-width="2"/>

          <line x1="1" y1="12" x2="3" y2="12" stroke="currentColor" stroke-width="2"/>

          <line x1="21" y1="12" x2="23" y2="12" stroke="currentColor" stroke-width="2"/>

          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke="currentColor" stroke-width="2"/>

          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke="currentColor" stroke-width="2"/>

        </svg>

      `;



      toggleBtn.addEventListener('click', toggleTheme);



      // Insert at the end of navbar

      const navbarContainer = document.querySelector('.navbar-collapse') || navbar.parentElement;

      if (navbarContainer) {

        navbarContainer.appendChild(toggleBtn);

      }

    }

  }



  function toggleTheme() {

    const currentTheme = document.documentElement.getAttribute('data-theme');

    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';



    document.documentElement.setAttribute('data-theme', newTheme);

    localStorage.setItem('theme', newTheme);

  }



  // =============================================

  // PROGRESS TRACKING

  // =============================================

  function initProgressTracking() {

    // Only run on exercise pages

    const radioGroups = document.querySelectorAll('.webex-radiogroup');

    if (radioGroups.length === 0) return;



    const pageId = window.location.pathname;

    const totalQuestions = radioGroups.length;



    // Get saved progress

    let progress = JSON.parse(localStorage.getItem('exerciseProgress') || '{}');

    if (!progress[pageId]) {

      progress[pageId] = {};

    }



    // Create progress bar

    const progressContainer = document.createElement('div');

    progressContainer.className = 'progress-container';

    progressContainer.innerHTML = `

      <div class="progress-inner">

        <div class="progress-header">

          <span class="progress-title">Progression</span>

          <span class="progress-count"><span id="progress-done">0</span> / ${totalQuestions} questions</span>

        </div>

        <div class="progress-bar-wrapper">

          <div class="progress-bar-fill" id="progress-fill" style="width: 0%"></div>

        </div>

      </div>

    `;



    // Insert into body (fixed positioning)

    document.body.appendChild(progressContainer);

    document.body.classList.add('has-progress-bar');



    // Track each question

    radioGroups.forEach((group, index) => {

      const questionId = `q${index + 1}`;



      // Check if already answered

      if (progress[pageId][questionId]) {

        updateQuestionBadge(index, true);

      }



      // Listen for changes - only mark complete on CORRECT answer

      group.querySelectorAll('input[type="radio"]').forEach(radio => {

        radio.addEventListener('change', () => {

          // Check if this is the correct answer (value="answer")

          if (radio.value === 'answer') {

            progress[pageId][questionId] = true;

            localStorage.setItem('exerciseProgress', JSON.stringify(progress));

            updateProgressBar(pageId, totalQuestions);

            updateQuestionBadge(index, true);

          }

        });

      });

    });



    // Initial progress update

    updateProgressBar(pageId, totalQuestions);

  }



  function updateProgressBar(pageId, total) {

    const progress = JSON.parse(localStorage.getItem('exerciseProgress') || '{}');

    const pageProgress = progress[pageId] || {};

    const done = Object.keys(pageProgress).length;

    const percentage = total > 0 ? (done / total) * 100 : 0;



    const fillEl = document.getElementById('progress-fill');

    const countEl = document.getElementById('progress-done');



    if (fillEl) fillEl.style.width = percentage + '%';

    if (countEl) countEl.textContent = done;

  }



  function updateQuestionBadge(index, completed) {

    const badge = document.querySelector(`[data-question-index="${index}"] .question-badge`);

    if (badge && completed) {

      badge.classList.add('completed');

      // Add checkmark if not already present

      if (!badge.querySelector('.badge-check')) {

        const check = document.createElement('span');

        check.className = 'badge-check';

        check.textContent = ' ‚úì';

        badge.appendChild(check);

      }

    }

  }



  // =============================================

  // QUESTION BADGES

  // =============================================

  function initQuestionBadges() {

    // Find all h2 elements that contain "Question" or are in exercise sections

    const mainContent = document.querySelector('main.content') || document.querySelector('main');

    if (!mainContent) return;



    const h2Elements = mainContent.querySelectorAll('h2');

    let questionNumber = 0;



    h2Elements.forEach((h2, index) => {

      // Check if this h2 is followed by a radio group (indicating it's a question)

      let nextElement = h2.nextElementSibling;

      let hasRadioGroup = false;



      // Look ahead up to 5 elements for a radio group

      for (let i = 0; i < 5 && nextElement; i++) {

        if (nextElement.classList && nextElement.classList.contains('webex-radiogroup')) {

          hasRadioGroup = true;

          break;

        }

        if (nextElement.querySelector && nextElement.querySelector('.webex-radiogroup')) {

          hasRadioGroup = true;

          break;

        }

        nextElement = nextElement.nextElementSibling;

      }



      if (hasRadioGroup) {

        questionNumber++;



        // Check if h2 already contains "Question X" text

        const h2Text = h2.textContent.trim();

        const questionMatch = h2Text.match(/^Question\s+(\d+)/i);



        // Create badge

        const badge = document.createElement('span');

        badge.className = 'question-badge';

        badge.textContent = `Q${questionNumber}`;



        // Add data attribute for progress tracking

        h2.setAttribute('data-question-index', questionNumber - 1);



        // Check if already completed

        const pageId = window.location.pathname;

        const progress = JSON.parse(localStorage.getItem('exerciseProgress') || '{}');

        if (progress[pageId] && progress[pageId][`q${questionNumber}`]) {

          badge.classList.add('completed');

        }



        // If h2 already says "Question X", just add the badge (which shows Q1, Q2, etc.)

        // The badge serves as a visual indicator without duplicating text

        h2.insertBefore(badge, h2.firstChild);

      }

    });

  }



  // =============================================

  // BREADCRUMBS

  // =============================================

  function initBreadcrumbs() {

    // Only add breadcrumbs on exercise pages

    const isExercisePage = window.location.pathname.includes('exercices_semaine');

    if (!isExercisePage) return;



    const mainContent = document.querySelector('main.content') || document.querySelector('main');

    if (!mainContent) return;



    // Extract week number from URL

    const weekMatch = window.location.pathname.match(/exercices_semaine_(\d+)/);

    const weekNumber = weekMatch ? weekMatch[1] : '';



    const breadcrumbs = document.createElement('nav');

    breadcrumbs.className = 'breadcrumbs';

    breadcrumbs.setAttribute('aria-label', 'Fil d\'Ariane');

    breadcrumbs.innerHTML = `

      <a href="index.html">Accueil</a>

      <span class="separator">‚Ä∫</span>

      <span class="current">Exercices Semaine ${weekNumber}</span>

    `;



    // Insert at the beginning of main content

    mainContent.insertBefore(breadcrumbs, mainContent.firstChild);

  }



  // =============================================

  // INITIALIZE ALL FEATURES

  // =============================================

  function init() {

    initDarkMode();

    initBreadcrumbs();

    initQuestionBadges();

    initProgressTracking();

  }



  // Run when DOM is ready

  if (document.readyState === 'loading') {

    document.addEventListener('DOMContentLoaded', init);

  } else {

    init();

  }

})();

</script>

<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("intro-statistique\.netlify\.app");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>